/** 
If itâ€™s an important memory, then you shouldn't forget it. Since those who aren't with us only live on in our memories.        
*/
#include <bits/stdc++.h>
#define forn(i, l, r) for(int i=l;i<=r;i++)
#define all(v) v.begin(),v.end()
#define pb push_back
#define nd second
#define st first
#define sz(x) (int)x.size()
#define UNIQUE(v) (v).resize(unique(all(v)) - (v).begin())
#define mp make_pair
#define debug(x) cout<<#x<<" --> "<<x<<endl;

using namespace std;
typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<long long> vll;
typedef vector<pair<int, int> > vpi;
typedef pair<int, int> pi;
typedef pair<ll, ll> pll;
typedef vector<pll> vpll;

const int INF = 1 << 30;
/**
Start coding from here
*/
int tc;
const int maxn=1e3+5;
int a[maxn], j[maxn], dp[maxn][1 << 11], lu[maxn][1<<11], pr[35], book[maxn];
int no[maxn];
ll _sieve_size;
bitset<10010> bs;                     // 10^7 should be enough for most cases
vll primes;               // compact list of primes in form of vector<long long>


// first part

inline void sieve(ll upperbound) {          // create list of primes in [0..upperbound]
  _sieve_size = upperbound+1;                     // add 1 to include upperbound
  bs.set();                                                 // set all bits to 1
  bs[0] = bs[1] = 0;                                     // except index 0 and 1
  for (ll i = 2; i < _sieve_size; i++) if (bs[i]) {
    // cross out multiples of i <= _sieve_size starting from i*i
    for (ll j = i*i; j < _sieve_size; j += i) bs[j] = 0;
    primes.push_back(i);       // also add this vector containing list of primes
} }                                           // call this method in main method


inline int primeFactors(ll N) {   // remember: vi is vector of integers, ll is long long
	// if(N<=3) return N-1;
  int ans=0;                   // vi `primes' (generated by sieve) is optional
  ll PF_idx = 0, PF = primes[PF_idx];     // using PF = 2, 3, 4, ..., is also ok
  while ((N != 1) && (PF*PF <= N)) {   // stop at sqrt(N), but N can get smaller
    while (N%PF == 0) { 
		N /= PF;
		if (PF <= 31) ans |= 1 <<(pr[PF]); }      // remove this PF
    PF = primes[++PF_idx];                              // only consider primes!
  }
  if (N != 1 && N <= 31) ans |= 1 << pr[N];     // special case if N is actually a prime
  return ans;         // if pf exceeds 32-bit integer, you have to change vi
}

inline int lgpr(ll N) { 
	if (N==1) return 1;  // remember: vi is vector of integers, ll is long long
  vi factors;                    // vi `primes' (generated by sieve) is optional
  ll PF_idx = 0, PF = primes[PF_idx];     // using PF = 2, 3, 4, ..., is also ok
  while ((N != 1) && (PF*PF <= N)) {   // stop at sqrt(N), but N can get smaller
    while (N%PF == 0) { N /= PF; factors.push_back(PF); }      // remove this PF
    PF = primes[++PF_idx];                              // only consider primes!
  }
  if (N != 1) factors.push_back(N);     // special case if N is actually a prime
  return factors.back();       // if pf exceeds 32-bit integer, you have to change vi
}

int n;
int solve(int cur, int mask) {
	if (cur == n) return 0;
	if (dp[cur][mask] != -1 && lu[cur][mask]==tc) return dp[cur][mask];
	int& ans = dp[cur][mask] = 0;
	lu[cur][mask]=tc;
	if (!(mask & book[a[cur]])) ans=max(ans, 1 + solve(j[cur], mask | book[a[cur]]));
	ans=max(ans, solve(cur+1, mask));
	return ans;
}
int main() {
	ios_base::sync_with_stdio(false); cin.tie(0);
	#ifdef LOCAL_PROJECT
		freopen("input.txt","r",stdin);
	#endif
	sieve(10000);
	forn(i, 0, 12) pr[primes[i]]=i;
	forn(i, 1, 1000) {
		book[i] = primeFactors(i);
		no[i]=lgpr(i);
	}
	cin>>tc;
	memset(dp, -1, sizeof dp);
	memset(lu, -1, sizeof lu);
	while(tc--) {
		cin>>n;
		forn(i,0,n-1) cin>>a[i];
		sort(a, a+n,[](const int& lhs, const int& rhs) {
			return no[lhs] < no[rhs];
		});
		int prev = 0;
		forn(i, 1, n-1) {
			if (no[a[i]] <= 31) j[prev++]=i;
			else if (no[a[i]] != no[a[i-1]]) for(;prev<i;prev++) j[prev]=i;
		}
		for(;prev<=n-1;prev++) j[prev]=n;
		cout<<solve(0, 0) <<'\n';
	}
	return 0;
}
