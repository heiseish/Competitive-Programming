/** 
The only ones who can miss a kick draw are those who have the courage to kick it.        
*/
#include <bits/stdc++.h>
#define forn(i, l, r) for(int i=l;i<=r;i++)
#define all(v) v.begin(),v.end()
#define pb push_back
#define nd second
#define st first
#define debug(x) cout<<#x<<" -> "<<x<< endl
#define rsa(x, y) memset(x, y, sizeof x);

using namespace std;
typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<bool> vb;
typedef vector<string> vs;
typedef vector<double> vd;
typedef vector<long long> vll;
typedef vector<vector<int> > vvi;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef vector<vpi> vvpi;
typedef pair<int, int> pi;
typedef pair<ll, ll> pll;
typedef vector<pll> vpll;
typedef unordered_map<int, int> um;
const int INF = 1 << 30;
/**
Start coding from here
*/

ll _sieve_size;
bitset<10000010> bs;                     // 10^7 should be enough for most cases
vll primes;               // compact list of primes in form of vector<long long>


// first part

void sieve(ll upperbound) {          // create list of primes in [0..upperbound]
  _sieve_size = upperbound+1;                     // add 1 to include upperbound
  bs.set();                                                 // set all bits to 1
  bs[0] = bs[1] = 0;                                     // except index 0 and 1
  for (ll i = 2; i < _sieve_size; i++) if (bs[i]) {
    // cross out multiples of i <= _sieve_size starting from i*i
    for (ll j = i*i; j < _sieve_size; j += i) bs[j] = 0;
    primes.push_back(i);       // also add this vector containing list of primes
} }   

ll numDiv(ll N) {
  ll PF_idx = 0, PF = primes[PF_idx], ans = 1;             // start from ans = 1
  while (N != 1 && (PF*PF <= N)) {
    ll power = 0;                                             // count the power
    while (N%PF == 0) { N /= PF; power++; }
    ans *= (power+1);                                // according to the formula
    PF = primes[++PF_idx];
  }
  return (N != 1) ? 2*ans : ans;    // (last factor has pow = 1, we add 1 to it)
}

um primeFactors(ll N) {   // remember: vi is vector of integers, ll is long long
  um factors;                    // vi `primes' (generated by sieve) is optional
  ll PF_idx = 0, PF = primes[PF_idx];     // using PF = 2, 3, 4, ..., is also ok
  while ((N != 1) && (PF*PF <= N)) {   // stop at sqrt(N), but N can get smaller
    while (N%PF == 0) { N /= PF; factors[PF]++; }      // remove this PF
    PF = primes[++PF_idx];                              // only consider primes!
  }
  if (N != 1) factors[N]++;     // special case if N is actually a prime
  return factors;         // if pf exceeds 32-bit integer, you have to change vi
}

void add(um& lhs, um rhs) {
	for (auto &v : rhs) 
		lhs[v.st] += v.nd;
}

void mn(um& lhs, um rhs) {
	for (auto &v : rhs) 
		lhs[v.st] -= v.nd;
}
ll solve( int n, int k ) {
    if (k > n) return 0;
    if (k * 2 > n) k = n-k;
    if (k == 0) return 1;

    um result = primeFactors(n);
    for( int i = 2; i <= k; ++i ) {
        add(result, primeFactors(n-i+1));
        mn(result, primeFactors(i));
    }
	ll ans = 1;
	for (auto &v : result) ans *= (1 + v.nd);
    return ans;
}


int main() {
	// ios_base::sync_with_stdio(false); cin.tie(0);
	const int maxn = 1e7 + 3;
	sieve(maxn);
	int n, k;
	while (scanf("%d %d", &n, &k) != EOF) {
		printf("%lld\n", solve(n, k));
	}
	return 0;
}
